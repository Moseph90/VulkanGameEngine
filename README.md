# VulkanEngine
 A 3D Graphics/Game Engine

 In order to run this program, you need to install and configure VulkanSDK. You can visit the Vulkan Tutorial website to go through the steps: https://vulkan-tutorial.com/Development_environment | You will also need to know how to compile the .vert and .frag files ***This is Important*** : You must go to the main project folder in your file explorer and run the compile.bat file. The compile.bat file will clean and compile the .vert and .frag files as your IDE/system cannot compile them. The reason for this is that it is not written in C++ but in GLSL which is a graphics card language similar to C++. Also, in the actual code, I did not go into detail explaining the validation layers because honestly I don't understand them. The purpose of them is to help with the build process so that any mistakes that you make will be caught so that you're not left in the dark. Although I know how to use it, any in depth knowledge of how it works can be found in the URL above. Most of the validation layers can be found in the Device.cpp file.

 This file is structured in a classic C++ way. There are .h files and .cpp files. Some of the function definitions are in the header files if they are small enough and most will be in the corresponding cpp file.

As of now, the program creates a colored cube and has a virtual camera that you can control with WASD and the middle mouse button + mouse motion (at the same time). WASD controls the translation of the camera in world space, E and Q for up and down, and the middle mouse button + mouse motion controls the rotation our camera in world space. Right now, it's set to perspective mode.

 If you wish to change the present mode, or rather check for additional present modes that are supported by your graphics cards, go to the SwapChain.cpp file and see the chooseSwapPresentMode function. There, you will see that the program checks for mailbox present mode and then defaults to FIFO(V-sync). If you wish to check for Immediate present mode, simply uncomment the chunk of code from line 404 to 409. After implementing the delta time feature, the cube's movement should remain consistent.

 If you have an AMD graphics card, you may get some validation warnings in the console. These are just the validation layers looking for a render pass that hasn't been created yet. The render pass does get created and that warning goes away. Also this is using a more recent version of Vulkan (version 1.1) and so I'm not too sure on the changes to the validation layers. Most of the Vulkan documentation and general knowledge revolves around version 1.0. This includes the validation layers. From what I've been able to gather, Vulkan is  buggy with AMD. If you have an NVIDIA graphics card, please let me know how it runs.

To have the best chance of understanding the program, go to the Application.h/Application.cpp files. This is the heart of the program and is what all of the builder classes connect to. From there, you will find extensive commentary to help you understand what everything does. The entire program loop runs in the run() function in the Application.h/Application.cpp file. If you start at the top of the h file, you will see some objects being created which in turn start an extensive build process. This URL is a great visualization of the graphics pipeline steps and how they connect: https://vulkan.lunarg.com/doc/view/latest/windows/tutorial/html/14-init_pipeline.html | Note that the GameObject class uses the Model class to create models and so the Application class does not use the Model class directly but rather through the GameObject class.

Follow the functions in the Application class to get a good understanding of the flow of the program. I did my best to include as much commentary as possible in order to explain how it all works, but in the end, a graphics engine (especially Vulkan) is very complicated and requires a lot of study. If you are in doubt, see the Vulkan API here: https://docs.vulkan.org/guide/latest/protected.html | Enjoy!